## Actor
**동시성 문제를 원천적으로 차단하는 타입**

---

액터(actor)는 Swift에서 내부 저장 프로퍼티에 대한 데이터 경합(data race) 문제를 언어 차원에서 해결해주는 **참조 타입(reference type)**입니다. 클래스와 달리 액터는 개발자가 직접 **락(lock)**이나 **직렬 디스패치 큐(serial dispatch queue)**를 구현하지 않아도, **공유된 가변 상태(shared mutable state)**에 대한 동기화(synchronization)를 Swift가 자동으로 보장합니다.

> 💡 **Note:** 
>  액터는 클래스와 마찬가지로 힙(heap) 메모리 영역에 저장되는 **참조 타입**입니다. 프로퍼티, 메서드, 이니셜라이저, 서브스크립트를 정의할 수 있으며, 프로토콜 채택과 확장(extension)도 지원합니다. 다만, 액터는 상속이 불가능하기 때문에 구조체처럼 `final`, `override` 그리고 편의 이니셜라이저(convenience initializer)를 사용할 수 없습니다. 

액터를 사용하면 개발자가 직접 동기화 메커니즘을 구현할 필요가 사라집니다. Swift는 여러 작업 컨텍스트(스레드)가 액터 내부 상태에 동시에 접근하려는 시도를 자동으로 감지하고, 한 번에 하나의 작업만 실행되도록 직렬화하여 **데이터 경합(data race)**의 가능성을 원천적으로 차단합니다. 이로 인해 직접 락(lock)이나 큐를 다루면서 생길 수 있는 구현 실수를 예방할 수 있으며, 더욱 효율적이고 스레드에 안전한 코드를 작성할 수 있습니다. 액터는 참조 타입으로, 여러 작업 컨텍스트에서 공유될 수 있지만, Swift는 내부적으로 이를 순차 처리함으로써 동시 접근으로 인한 문제를 근본적으로 해결합니다.

액터는 (명시적으로 `nonisolated` 키워드를 적지 않는다면) 프로그램의 나머지 부분으로부터 **내부 프로퍼티와 메서드를 격리(isolate)**하여, 상태를 안전하게 보호합니다. 외부 코드에서 액터의 내부 상태에 접근하거나 수정하려면, 반드시 비동기(async) 방식으로 접근해야 하며 `await` 키워드를 사용해야 합니다. 이러한 제한은 동시에 여러 작업 컨텍스트가 동일한 액터에 접근하려고 시도하더라도, 작업들을 순차적으로 처리하여 충돌 없이 안정적인 상태 관리를 가능하게 합니다. 즉, 다른 작업은 현재 작업이 완료될 때까지 잠시 대기하게 되어, 동시성으로 인한 문제를 방지할 수 있습니다.

엑터는 `actor` 키워드를 사용해 선언하며, 기본적인 구조와 사용법은 클래스와 유사합니다. 단, 동시성 보호를 위해 액터는 몇 가지 제약과 특수한 동작을 가집니다.

```swift
actor Counter {
    var value: Int = 0
    
    func increment() -> Int {
        value += 1
        return value
    }
}
```

```swift
let counter = Counter()
Task { _ = await countere.incrment() }
```

이렇듯, 액터 외부에서 내부 메서드에 접근하려면 반드시 `await` 키워드를 사용해야 합니다. 이는 액터의 격리된 상태에 안전하게 접근하도록 Swift가 강제하는 규칙입니다. 아래는 Counter 액터를 확장하여 `resetSlowly(to:)` 메서드를 추가한 예제입니다.

```swift
extension Counter {
    func resetSlowly(to newValue: Int) {
        value = 0
        
        for _ in 0..<newValue {
            self.increment()
        }
        assert(value == newValue)
    }
}
```

`resetSlowly(to:)` 메서드는 액터 내부에 정의된 메서드이므로, 같은 액터의 다른 메서드인 `increment()`를 동기적으로 호출할 수 있습니다. 즉, Swift는 동일한 액터에 격리된 메서드 간 호출에 대해 `await`를 요구하지 않습니다. 같은 액터 내부에서는 비동기 처리 없이도 안전하게 상태를 공유하고 변경할 수 있습니다.


```swift
func increment(by count: Int, onto counter: Counter) async {
    var value = await counter.value
    value += count
    await counter.value = value // 🔴
}
```

아울러, 외부 작업 컨텍스트에서 액터의 내부 상태를 바꾸길 원하는 경우, 액터의 격리 메서드에 바꿀 데이터를 전달하는 방식으로 구현해야 합니다. `await counter.value = ...`와 같이 해당 프로퍼티에 접근해 직접 새로운 값을 할당할 수 없습니다. 아래 예제는 위 예제의 문제를 해결한 코드입니다.

```swift
// 1️⃣ Counter 액터 내부에 상태를 변경하는 메서드를 구현
extension Counter {
    func increment(by count: Int) {
        var value = self.value
        value += count
        self.value = value
    }
}

// 2️⃣ 전역 함수를 특정 액터에 격리시켜 구현
func increment(by count: Int, onto counter: isolated Counter) {
    var value = counter.value
    value += count
    counter.value = value
}
```

1️⃣번 코드는 `increment(by:)` 메서드를 Counter 액터에 격리시키고, 해당 메서드를 통해서만 바꾸도록 구현한 예제입니다. 가장 일반적인 코드입니다.
2️⃣번 코드는 `increment(by:counter:)` 전역 함수를 특정 액터에 격리시키는 방법입니다.  actor 타입 매개변수 앞에 isolated 키워드를 붙이면 해당 전역 함수가 매개변수로 주어진 액터 인스턴스로 격리됨, 외부에 구현되어 있어도 액터 내부에 구현된 격리 메서드마냥 작동되는 특권을 얻음




그런데 액터는 내부 상태에 대해 어떻게 상호 배제를 보장할 수 있을까요? 액터는 모든 작업을 순차적으로 처리하는 직렬 실행자(serial executor)를 가집니다. 외부 작업 컨텍스트에서 액터의 내부 상태에 접근하거나 메서드를 호출하면 해당 작업은 실행자에 _Job_으로 등록되어 직렬화되며, 한 번에 하나의 작업만 처리하게 함으로써 데이터 경합(data race)의 가능성을 원천적으로 차단합니다. 이 직렬 실행자는 디스패치 직렬 큐와 유사하지만 단순한 선입선출(FIFO) 방식은 아니며, 작업의 우선순위를 파악해 실행 순서를 재조정할 수 있는 유연한 구조를 가집니다. 

> 💡 **Note:** 액터는 암시적으로 `Actor` 프로토콜을 채택합니다. `Actor` 프로토콜은 **UnownedSerialExecutor** 타입의 `unownedExecutor` 프로퍼티를 요구하며, 이는 액터가 작업을 스케줄링해야 할 때 Swift 런타임에 의해 암시적으로 접근됩니다. 이러한 접근은 다른 작업과 합쳐지거나, 제거되거나, 재배치될 수 있으며, 반드시 필요한 상황이 아니어도 삽입될 수 있습니다. 

> 💡 **Note:** 액터는 `Sendable` 프로토콜을 채택합니다.

 
 

### 액터 격리(Actor Isolation)

내부 프로퍼티와 메서드를 액터에 격리한다는 것은 무슨 의미일까요? 액터 격리(actor isolation)는 액터 내부의 상태(프로퍼티 및 메서드)를 프로그램의 나머지 부분으로부터 보호한다는 의미입니다. 즉, 해당 상태는 특정 실행 컨텍스트에 단독으로 소속되어 있으며, 여러 스레드에서 동시에 접근하는 일이 없도록 액터에게만 단독 접근 권한을 부여하는 것을 의미합니다.

액터에 상태가 격리되어 있다는 것은 그 상태에 접근할 수 있는 작업은 액터가 사용하는 스레드(실행 컨텍스트)에서만 수행된다는 뜻이며, 다른 스레드에서 실행되는 다른 작업 컨텍스트에서는 직접 접근이 불가능합니다. 액터 격리는 동시성 환경에서의 안정성을 확보하기 위한 개념이며, 결국 특정 상태나 작업이 하나의 실행 흐름에만 속하도록 제한함으로써 충돌 없는 안전한 실행을 보장합니다.


```
┌──────────────────────────────┐
│       프로그램의 나머지 부분       │
│  ┌────────────────────────┐  │
│  │  Task A                │  │
│  │  await counter.inc()   │ ─│───┐  
│  └────────────────────────┘  │   │      
│                              │   │ 👷🏼‍♀️ 작업 요청 전달!
│  ┌────────────────────────┐  │   │
│  │  Task B                │  │   │
│  │  await counter.get()   │ ─│─┐ │
│  └────────────────────────┘  │ │ │ 👷🏻 작업 요청 전달!
└──────────────────────────────┘ │ │
                                 ▼ ▼
┌─────────────────────────────────────┐
│            actor Counter            │
│─────────────────────────────────────│
│  (격리된 내부 상태)                     │
│  var value: Int                     │
│                                     │
│  func increment() -> Int            │
│  func get() -> Int                  │
│                                     │
│  🔒 내부 상태는 액터만 직접 접근 가능       │
└─────────────────────────────────────┘
            ▼
┌──────────────────────┐
│  Serial Executor     │  ◀─ 작업들을 순차적으로 처리하고, 그 결과를 다시 반환함
└──────────────────────┘
```

> 💡 **Note:** 액터 격리는 작업 격리(task isolation)와 본질적으로 동일한 개념입니다!

액터 격리의 핵심은 서로 다른 격리 컨텍스트에서 액터 내부 상태에 접근하려는 시도가 있을 때, 해당 작업을 액터의 직렬 실행자에 등록해 순차적으로 실행되도록 함으로써, 데이터 경합 없이 안전한 접근을 보장하는 데 있습니다. 즉, **격리된 객체끼리는 직접 상태를 건드리지 않고 작업 요청만 비동기적으로 전달** 하며, 이 요청은 액터 내부에서 하나씩 정해진 순서에 따라 실행되기 때문에 잠재적인 동시성 문제가 자연스럽게 사라지는 구조입니다. 


##### Non-Sendable 클로저(Closure)

```swift
struct Book: Sendable {
    let title: String
    let pages: Int
}
actor LibraryAccount {
    let booksOnLoan: [Book] = []
    func read() -> Int {
        return booksOnLoan.reduce(0) { book in
            readSome(book)
        }
    }
}
```

클로저는 하나의 함수 내에 정으된 작은 함수들로, 클로저도 마찬가지로 액터에 격리되거나 비격리(isolated)될 수 있습니다. 위 예제는 우리가 대출한 책의 총 페이지 수를 계산해 반환하려고 합니다. `reduce` 호출에는 지금까지 빌린 책의 페이지 수의 총 합을 반환하는 클로저가 있습니다. 그리고 해당 클로저 내부에 _getPages()_ 호출에는 `await`이 없다는 점을 주목하세요. 이는 해당 클로저가 액터에 격리된 함수인 _totalPagesBorrowed()_ 내부에서 생성되었기 때문이며, 따라서 해당 클로저 자체도 액터에 격리되어 있기 때문입니다.



#### 비격리(non-Isolated)

액터가 격리 상태를 갖는다면, 당연히 비격리(non-isolated) 상태도 가질 수 있습니다. 비격리는 액터 내부의 상태를 프로그램의 나머지 부분으로부터 보호하지 않겠다는 의미입니다. 즉, 해당 상태는 특정 실행 컨텐스트에 소속되어 있지 않으며, 여러 스레드(작업 컨텍스트)에서 아무런 제약없이 동시에 접근할 수 있습니다.

액터의 프로퍼티나 메서드를 비격리로 만들 때는 해당 선언 앞에 `nonisolated` 키워드를 붙이면 됩니다. 이 키워드는 주로 `let`으로 선언되어 불변(immutable)이며 보호가 필요 없는 프로퍼티나 액터 내부 상태에 접근하지 않는 메서드에 적용됩니다. 동시 접근에도 데이터 경합(data race)이 발생할 가능성이 없는 코드에 굳이 액터 격리를 유지하면서 `await`으로 접근한다면, 불필요한 리소스 낭비로 이어질 수 있습니다. 따라서, 이러한 경우에는 `nonisolated`를 활용해 성능을 높일 수 있습니다.

```swift
actor Counter {
    var value = 0
    nonisolated let label: String = 123
    
    nonisolated func getLabel() -> String {
        return label
    }
    nonisolated func getDoulbedValue() -> Int {
        return await self.value * 2
    }
}

let counter = Counter()
_ = counter.getLabel()
Task { await counter.getDoulbedValue() }
```

액터 내부에 비격리로 선언된 메서드는 외부에서 `await` 없이 자유롭게 호출할 수 있습니다. 또한, 이러한 메서드는 액터 내부의 비격리 프로퍼티에도 제약 없이 접근할 수 있습니다. 하지만 중요한 점은 비격리된 프로퍼티나 메서드는 액터 내부에 정의되어 있더라도, 실질적으로 액터 외부에 구현된 것처럼 간주한다는 것입니다. 따라서, 비격리된 메서드가 격리된 상태에 접근하려는 경우, 이는 외부에서 액터 내부에 접근을 시도하는 것과 동일하게 처리되며 반드시 `await`을 사용해 비동기적으로 접근해야 합니다.



##### Hashable 프로토콜

```swift
extension Counter: Hashable {
    nonisolated func hash(into hasher: inout Hasher) {
        hasher.combine(self.label)
    }
}
```

**Counter**를 **Hashable** 프로토콜을 따르도록 만들기 위해서는 `hash(into:)` 메서드를 구현해야 합니다. 하지만 이 메서드를 액터 내부의 격리된 컨텍스트에서 그대로 구현하면 문제가 발생합니다. 이유는 `hash(into:)`가 일반적으로 외부 모듈에서 동기적으로 호출되며, 비동기 컨텍스트에서 실행할 수 없기 때문입니다. 따라서 이 메서드를 `nonisolated`으로 선언하여, 외부에서 동기적으로 호출 가능하게 만들어야 합니다. 이때 접근하는 프로퍼티 역시 비격리 상태에 있어야 합니다.


##### Equatable 프로토콜

```swift
extension Counter: Equtable {
    nonisolated static func == (lhs: LibraryAccount, rhs: LibraryAccount) -> Bool {
        return lhs.label == rhs.label
    }
}
```

**Counter** 액터를 **Equatable** 프로토콜을 따르도록 만들어봅시다. 정적 메서드 ==는 두 인스턴스의 레이블(label) 값을 기준으로 동등성을 비교합니다. ==는 정적(static) 메서드이므로, 액터 인스턴스의 격리된 상태에 직접 접근하지 않습니다. 따라서 이 정적 메서드는 액터에 격리될 필요가 없습니다.


##### Detached Task

```swift
extension Counter {
    func increment(times: any UnsignedInteger) {
        Task.detached {
            for _ in 0..<times {
                await self.increment()
            }
        }
    }
}
```

액터 내부에서 **Detached Task**를 생성하는 경우, 이 **Detached Task**는 액터를 포함한 어떤 자원도 상속받지 않는 독립적인 작업 컨텍스트입니다. 따라서 이 작업 컨텍스트는 액터에 격리되지 않습니다. 그렇기 때문에 이 작업 컨텍스트 안에서 액터 내부의 상태에 접근하려면, 반드시 `await`을 사용해 비동기적으로 접근해야 합니다.





### 액터의 재진입성(Actor Re-entrancy)

액터의 재진입성은 액터의 격리 메서드가 비동기적인 작업으로 인해 일시 중단이 되고, 다시 재개가 될 때 액터의 내부 상태가 await 이전과 이후가 서로 다를 수 있음을  나타내는 표현입니다. 액터는 외부와의 비동기적 의사소통에 따라 작업이 일시 중단되다가 다시 재개될 수 있는데, 이때 재개 시점의 액터의 데이터가 (이전과 동일하지 않고) 바뀌었을 수 있다는 의미입니다.


    **액터의 재진입성(Reentrancy)**은 미묘한 버그와 예기치 못한 결과를 초래할 수 있는 액터의 특징입니다.
이러한 재진입성 때문에, 액터에 async 메서드를 추가할 때는 매우 주의해야 하며,
특정 함수에 여러 개의 재진입 호출이 동시에 발생할 수 있다는 점을 염두에 두고 무엇이, 어떻게 동작해야 하는지를 충분히 고민해야 합니다.

    어떤 경우에는 재진입이 전혀 문제가 되지 않거나, 비효율적이긴 해도 시스템에 영향을 주지 않을 수 있습니다.
그러나 다른 경우에는, 함수가 일시 중단(suspension) 되었던 사이에 액터의 내부 상태가 변경됨으로 인해 심각한 문제가 발생할 수도 있습니다.

    따라서, 액터 내부에서 await를 호출할 때마다, await 이전에 어떤 상태 기반의 가정( await 이전의 코드 흐름에서 액터의 내부 상태가 변하지 않을 것이라고 무의식적으로 믿고 있는 것)을 했는지 반드시 되돌아보고,
그 가정이 여전히 유효한지 await 이후에 다시 확인(re-verify) 해야 합니다.



액터의 재진입성으로 인해 잠재적으로 발생할 수 있는 액터의 버그를 이해하기 위해 아래 예제를 살펴보겠습니다. 아래는 이미지를 다운로드받아 캐시 형태로 딕셔너리에 저장하고 이미지를 반환하는 예제입니다. 

```swift

```

```
-----------------------------------------------------------------------
| downloadImage1️⃣ | 💥suspend --- | downloadImage2️⃣ | 💥suspend --- ➡️
-----------------------------------------------------------------------

-----------------------------------------------------------------------
➡️ --- ✨resume | downloadImage2️⃣ | --- ✨resume | downloadImage1️⃣ |
-----------------------------------------------------------------------
```

먼저, 외부 작업 컨텍스트에서 첫 번째 이미지 다운로드를 하는 작업을 요청했다고 가정해봅시다. 캐시에 해당 이미지가 없음을 확인하고, 곧바로 이미지를 다운로드하기 위해 일시 중단이 될 것입니다. 그리고 액터는 - 첫 번째 이미지 다운로드르 하는 작업이 일시 중단되어 있는 동안에 - 동일한 URL에 두 번째 이미지를 다운로드를 하는 작업을 수행할 수 있습니다. 그리고 첫 번째 이미지 다운로드 작업과 마찬가지로 캐시에 이미지가 없음을 확인하고, 이미지를 다운로드하기 위해 일시 중단이 될 것입니다. 그리고 이미지 다운로드를 마치고 "www.example.com/image"라는 URL로 이미지를 캐시에 저장합니다. 이후 첫 번째 이미지 다운로드 작업도 끝나 동일한 URL에 이미지를 캐시에 저장하게 됩니다. 이때 그냥 저장이 아니라 첫 번째 작업이 두 번째 작업의 결과물을 덮어 씌워지게 되는 거죠. 이것이 바로 액터의 재진입성으로 인해 발생하는 잠재적인 액터의 버그이자, 저수준의 데이터 경합(data race)이라 할 수 있습니다.

액터의 재진입성으로 인한 버그를 막기 위해선 `await` 이후에 액터로 재진입하는 시점에 액터의 데이터가 바뀔 가능성을 잘 고려해서 메서드를 설계해야 합니다. 재진입 시점 이후, 기존의 데이터가 바뀌었는지 확인하거나,  (2) Task의 상태를 저장하는 방식으로 구현해 두번째 이미지를 다운로드 작업에서 첫 번째 다운로드 작업이 실행됨을 인지할 수 있다면 이러한 버그를 막을 수 있을 것입니다.

```swift

```


```swift

```




### 액터 홉핑(Actor Hopping)

- 한 액터에서 다른 액터로 실행이 전환되는 액터 홉핑(actor hopping) 현상 -> 비효율적인 오버헤드, 스레드 컨텍스트 스위칭이 일어날 수 있음, 적절한 작업과 모델의 설계를 통해 성능 최적화 필요 (액터로 작업하는 것이 무조건적인 장점을 가지는 건 아니다!)


- 실제로는 더 많은 액터가 존재할 수 있습니다. 이러한 액터들은 협력형 스레드 풀에서 실행되며, 피드 액터들은 데이터베이스와 상호작용하면서 기사를 저장하거나 기타 작업을 수행할 수 있습니다. 이 과정에서 한 액터에서 다른 액터로 실행이 전환되는 액터 홉핑(actor hopping) 현상이 발생합니다.

. 첫째, 액터 홉핑이 이루어지는 동안 스레드는 블로킹되지 않았습니다. 둘째, 홉핑을 위해 새로운 스레드를 생성할 필요 없이, 런타임이 스포츠 피드 액터의 작업을 일시 중단하고 데이터베이스 액터를 위한 새로운 작업을 생성하여 실행을 계속할 수 있습니다.

비동기 작업이 많고 특히 경쟁 상태가 심한 경우, 시스템은 어떤 작업이 더 중요한지에 따라 적절한 트레이드-오프를 해야 합니다. 이상적으로는 사용자 상호작용과 관련된 고우선순위 작업이 백업 저장과 같은 백그라운드 작업보다 우선 처리되어야 합니다.

액터 홉핑은 서로 다른 액터(각자 다른 큐/실행 컨텍스트) 간의 호출 때문에, 실행 컨텍스트가 전환되며, 이로 인해 컨텍스트 스위칭이 발생한다! 액터 홉핑 시 “다른 액터의 실행자”로 전환하는 비용

- 가능하면 한 액터에서 많은 양의 일(ImageDataBase + DiskStorage) (ImageDownloader)을 처리하도록 해 액터 홉핑을 가능한 줄이는 게 좋다!


> 💡 **Note:** 액터 홉핑에 관한 자세한 내용은 [Actor Hopping]() 프로젝트를 참조하세요.


#### 액터 경합(Actor Contention)

- 액터 내부에서는 직렬 실행자 때문에 병렬 처리의 성능상 이점을 얻기 힘든 단점도 존재함 (병렬 처리가 필요한 작업은 액터 외부로 보내서 처리해야 함)

- 외부 Task에서 작업을 하다가 정말로 필요한 부분만 액터에서 실행시키도록 하면 좋음, 그래서 가능하면 액터에 접근할 때 가능한 한 작은 단위로 나누어서 접근을 하는 게 좋음

> 💡 **Note:** 액터 경합에 관한 자세한 내용은 [Actor Contention]() 프로젝트를 참조하세요.


<br>
<br>

---

### [부록] 액터의 원자성(Atomicity)

원자성(Atomicity)란 작업의 모든 단계를 완전히 수행하거나 아무 작업도 수행하지 않은 상태로 유지되어야 함을 의미합니다. 즉, 작업을 수행하다가 실패하면 이전에 수행된 모든 작업을 포함해 모든 작업이 롤백되어 이전 상태로 복원되어야 합니다. (All or Nothing) 일반적으로 디스크에 파일을 생성하거나 쓸 때 원자적 연산은 굉장히 중요합니다. 파일이 반만 쓰여질 수는 없기 때문이죠. (그렇게 되면 파일이 열리지 않겠죠?)

```
Counter actor
---------------------------------
| increment1️⃣ | 💥suspend --- | increment2️⃣ | 💥suspend --- ✨resume | increment1️⃣ | --- ✨resume | increment2️⃣ |
---------------------------------
```

액터도 마찬가자입니다. 액터 내부에 상태를 생성하거나, 수정해야 한다면 이러한 연산은 모두 원자적으로 이루어져야 합니다. 즉, 수정이 이루어지는 중간에 `await` 키워드를 만나 작업이 일시 중단(suspend)되고, 나중에 재개(resume)되지 않도록 해야 합니다. 이는 작업이 다시 재개될 때, 다른 작업 컨텍스트에서 동일한 액터에 접근해 상태를 바꿀 수 있는데, 이렇게 되면 액터 내에서 데이터가 의도치 않게 뒤바뀌는 버그가 발생할 수 있기 때문입니다.

```
extension Counter {
    func increment(random range: Range<Int>) async {
        var newValue = value
        let randomNumber = await randomNumber(range) // 💥 원자성 깨짐!
        newValue += randomNumber  // 😦 오래된 값으로 덮어쓰기
        value = newValue
    }
}
```

위 예제는 액터의 원자성이 깨지는 대표적인 예제입니다. 이 예제의 `increment(random:)` 메서드는 value를 읽고, 서버로부터 랜덤 숫자를 받아온 다음, 새롭게 값을 계산하고 value를 갱신하고 있습니다. 이 코드는 경쟁조건을 일으킬 가능성이 다분한데, 왜냐하면 서버로부터 랜덤 숫자를 받아오기 위해 await되는 사이에 다른 작업(increment2️⃣)이 value를 변경할 수 있기 때문입니다. increment1️⃣가 서버로부터 랜덤 숫자를 받아오기 위해 잠시 일시 중단되고, 다시 재개될 때의 `newValue`가 현재 `value` 값과 다를 가능성이 있습니다. 

```swift
extension Counter {
    func increment(random range: Range<Int>) async {
        let randomNumber = await randomNumber(range)
        value += randomNumber
    }
}
```

await 전에는 상태 읽지 말고,
모든 상태 변경은 await 이후, 격리 컨텍스트 안에서 하자!

이런 잠재적인 버그를 방지하기 위해선 데이터를 가져오고 수정하는 코드가 일시 중단되지 않고 처음부터 끝까지 멈추지 않고 실행되는 원자적 형태로 구현해야 함. 격리 메서드는 비동기적인 통신이 없다면 중간에 일시중단되면 안됨, 원자성 유지 구현 필요

